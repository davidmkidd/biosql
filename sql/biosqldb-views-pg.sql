--- THIS FILE IS EXPERIMENTAL; SOME OR ALL OF THESE COULD CHANGE

CREATE VIEW seqfeature_key_v
 AS SELECT f.*, key_name 
    FROM seqfeature f, seqfeature_key k 
    WHERE f.seqfeature_key_id = k.seqfeature_key_id;

DROP VIEW gffjoin;
CREATE VIEW gffjoin
 AS SELECT e.accession       AS fref, 
           fl.seq_start      AS fstart, 
           fl.seq_end        AS fend,
           term_name         AS type, 
           NULL              AS fscore,
           fl.seq_strand     AS fstrand, 
           NULL              AS fphase,
           f.seqfeature_id   AS gid,
           e.bioentry_id     AS bioentry_id
    FROM seqfeature f, 
         ontology_term k, 
         seqfeature_location fl,
         bioentry e
    WHERE f.seqfeature_key_id = k.ontology_term_id  AND
          fl.seqfeature_id = f.seqfeature_id        AND
          f.bioentry_id    = e.bioentry_id;

--- GFF is just a projection on gffjoin, to
--- get rid of unneeded attributes
DROP VIEW gff;
CREATE VIEW gff
 AS SELECT  fref, 
            fstart, 
            fend,
            type, 
            fscore,
            fstrand, 
            fphase,
            gid
    FROM gffjoin;

--- basic fasta view; we may have others where we
--- cram more into header
CREATE VIEW fasta
  AS SELECT '>'                        ||
            e.display_id               ||
            ' '                        ||
            bqv.qualifier_value        AS header,
            s.biosequence_str          AS residues
  FROM bioentry e,
       biosequence s,
       bioentry_qualifier_value bqv,
       ontology_term t
  WHERE e.bioentry_id = s.bioentry_id      AND
        e.bioentry_id = bqv.bioentry_id    AND
        bqv.ontology_term_id = t.ontology_term_id AND
        t.term_name = 'description';

--- fasta with length of seq appended
CREATE VIEW fasta_withlen
  AS SELECT fasta.header               || 
            ' length:'                 ||
            length(residues)           AS header,
            residues
  FROM fasta;

---
CREATE VIEW embl_FT
 AS SELECT fl.seq_start      ||
           '..'              ||
           fl.seq_end        AS floc,
           k.term_name       AS ftype, 
           qt.term_name      AS qterm,
           q.qualifier_value AS qval
    FROM seqfeature f, 
         ontology_term k, 
         ontology_term qt, 
         seqfeature_location fl,
         bioentry e,
         seqfeature_qualifier_value q
    WHERE k.ontology_term_id = f.seqfeature_key_id  AND
          qt.ontology_term_id = q.ontology_term_id AND
          fl.seqfeature_id = f.seqfeature_id        AND
          f.bioentry_id    = e.bioentry_id;


--- this should probably be autogenerated by
--- an ontology of mappings
CREATE VIEW embl
  AS SELECT e.display_id               AS ID,
            e.accession                AS AC,
            e.accession || 
            ' '         || 
            e.version                  AS SV,
            ;

DROP FUNCTION compl(text);
CREATE FUNCTION compl(text) RETURNS text AS
 'SELECT (translate($1, ''ACGT'', ''TGCA'')) as RESULT;'
LANGUAGE 'sql';

DROP FUNCTION reverse(text);
CREATE FUNCTION reverse(text) RETURNS text
  AS '/home/cjm/cvs/biosql-schema/ext/biosqldb-funcs.so' 
  LANGUAGE 'c'
  WITH (isStrict);
SELECT reverse('abcde');

DROP FUNCTION reverse_compl(text);
CREATE FUNCTION reverse_compl(text) RETURNS text
  AS 'SELECT(reverse(compl($1))) as RESULT;'
LANGUAGE 'sql';

DROP FUNCTION get_subseq(text,int,int,int);
CREATE FUNCTION get_subseq (text, int, int, int)
  RETURNS text
  AS 'SELECT CASE $4 > 0
        WHEN TRUE THEN
                   substring($1,
                      $2,
                     ($3 - $2)+1)
        ELSE
             reverse_compl(
                      substring($1,
                        $2,
                       ($3 - $2)+1)) 
        END
          AS RESULT
     '
  LANGUAGE 'sql';
select get_subseq('abcdefg',2,3,1);

DROP VIEW gffseq;
CREATE VIEW gffseq
  AS SELECT gff.*,
           get_subseq(s.biosequence_str,
                      fstart,
                      fend,
                      fstrand)
                             AS subseq
     FROM   gffjoin gff, biosequence s
     WHERE  gff.bioentry_id = s.bioentry_id;

DROP VIEW gffseq;
CREATE VIEW gffseq
 AS SELECT e.accession       AS fref, 
           fl.seq_start      AS fstart, 
           fl.seq_end        AS fend,
           key_name          AS type, 
           NULL              AS fscore,
           fl.seq_strand     AS fstrand, 
           NULL              AS fphase,
           f.seqfeature_id   AS gid,
           get_subseq(s.biosequence_str,
                      fl.seq_start,
                      fl.seq_end,
                      fl.seq_strand)
                             AS subseq
    FROM seqfeature f, 
         seqfeature_key k, 
         seqfeature_location fl,
         bioentry e,
         biosequence s
    WHERE f.seqfeature_key_id = k.seqfeature_key_id AND
          fl.seqfeature_id    = f.seqfeature_id        AND
          f.bioentry_id       = e.bioentry_id          AND
          f.bioentry_id       = s.bioentry_id;




--- these are autogenerated:

CREATE VIEW f_source AS
  SELECT * from seqfeature_key_v WHERE key_name = 'source';
CREATE VIEW f_misc_feature AS
  SELECT * from seqfeature_key_v WHERE key_name = 'misc_feature';
CREATE VIEW f_sig_peptide AS
  SELECT * from seqfeature_key_v WHERE key_name = 'sig_peptide';
CREATE VIEW f_CDS AS
  SELECT * from seqfeature_key_v WHERE key_name = 'CDS';
CREATE VIEW f_gene AS
  SELECT * from seqfeature_key_v WHERE key_name = 'gene';
CREATE VIEW f_mat_peptide AS
  SELECT * from seqfeature_key_v WHERE key_name = 'mat_peptide';
CREATE VIEW f_variation AS
  SELECT * from seqfeature_key_v WHERE key_name = 'variation';
CREATE VIEW f_exon AS
  SELECT * from seqfeature_key_v WHERE key_name = 'exon';
CREATE VIEW f_intron AS
  SELECT * from seqfeature_key_v WHERE key_name = 'intron';

