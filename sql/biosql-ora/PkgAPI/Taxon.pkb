--
-- API Package Body for Taxon.
--
-- Scaffold auto-generated by gen-api.pl (H.Lapp, 2002).
--
-- $Id: Taxon.pkb,v 1.1.1.1 2002-08-13 19:51:10 lapp Exp $
--

--
-- (c) Hilmar Lapp, hlapp at gnf.org, 2002.
-- (c) GNF, Genomics Institute of the Novartis Research Foundation, 2002.
--
-- You may distribute this module under the same terms as Perl.
-- Refer to the Perl Artistic License (see the license accompanying this
-- software package, or see http://www.perl.com/language/misc/Artistic.html)
-- for the terms under which you may use, modify, and redistribute this module.
-- 
-- THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
-- WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
-- MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
--

CREATE OR REPLACE
PACKAGE BODY Tax IS

taxon_cached SG_TAXON.OID%TYPE DEFAULT NULL;
cache_key VARCHAR2(128) DEFAULT NULL;

CURSOR Tax_NCBI_c (
		Tax_NCBI_TAXON_ID	IN SG_TAXON.NCBI_TAXON_ID%TYPE)
RETURN SG_TAXON%ROWTYPE IS
	SELECT t.* FROM SG_TAXON t
	WHERE
		t.NCBI_TAXON_ID = Tax_NCBI_TAXON_ID
	;

CURSOR Tax_Name_c (
		Tax_NAME		IN SG_TAXON.NAME%TYPE,
		TaxP_OID		IN SG_TAXON.TAX_OID%TYPE)
RETURN SG_TAXON%ROWTYPE IS
	SELECT t.* FROM SG_TAXON t
	WHERE
		t.NAME = Tax_NAME
	AND	(
		t.Tax_OID = TaxP_OID
	OR	TaxP_OID IS NULL
	)
	;

FUNCTION get_oid(
		Tax_OID	IN SG_TAXON.OID%TYPE DEFAULT NULL,
		Tax_NAME	IN SG_TAXON.NAME%TYPE,
		Tax_COMMON_NAME	IN SG_TAXON.COMMON_NAME%TYPE DEFAULT NULL,
		Tax_NCBI_TAXON_ID	IN SG_TAXON.NCBI_TAXON_ID%TYPE,
		TaxP_OID	IN SG_TAXON.TAX_OID%TYPE DEFAULT NULL,
		Tax_NODE_TYPE	IN SG_TAXON.NODE_TYPE%TYPE DEFAULT NULL,
		TaxP_NAME	IN SG_TAXON.NAME%TYPE DEFAULT NULL,
		TaxP_COMMON_NAME	IN SG_TAXON.COMMON_NAME%TYPE DEFAULT NULL,
		TaxP_NCBI_TAXON_ID	IN SG_TAXON.NCBI_TAXON_ID%TYPE DEFAULT NULL,
		do_DML		IN NUMBER DEFAULT BSStd.DML_NO)
RETURN SG_TAXON.OID%TYPE
IS
	pk	SG_TAXON.OID%TYPE DEFAULT NULL;
	Tax_row Tax_NCBI_c%ROWTYPE;
	TAX_OID_	SG_TAXON.OID%TYPE DEFAULT TaxP_OID;
	key_str VARCHAR2(128) DEFAULT Tax_NAME || '|' || Tax_NCBI_TAXON_ID;
BEGIN
	-- initialize
	IF (do_DML > BSStd.DML_NO) THEN
		pk := Tax_OID;
	END IF;
    	-- look up foreign keys if not provided:
	-- look up SG_TAXON
	IF (TAX_OID_ IS NULL) AND
	   ((TaxP_NAME IS NOT NULL) OR
	    (TaxP_NCBI_TAXON_ID IS NOT NULL)) THEN
		TAX_OID_ := Tax.get_oid(
				Tax_NAME => TaxP_NAME,
				Tax_COMMON_NAME => TaxP_COMMON_NAME,
				Tax_NCBI_TAXON_ID => TaxP_NCBI_TAXON_ID,
				do_DML => do_DML);
		IF (TAX_OID_ IS NULL) AND (do_DML > BSStd.DML_NO) THEN
			raise_application_error(-20101,
				'failed to look up Tax <' || TaxP_NAME || '|' || TaxP_NCBI_TAXON_ID || '>');
		END IF;
	END IF;
	-- look up
	IF (pk IS NULL) AND (key_str = cache_key) THEN
	        pk := taxon_cached;
	ELSIF (pk IS NULL) THEN
		-- reset cache
		cache_key := NULL;
		taxon_cached := NULL;
		-- look up primary key
		IF (Tax_NCBI_TAXON_ID IS NOT NULL) THEN
			FOR Tax_row IN Tax_NCBI_c(Tax_NCBI_TAXON_ID) LOOP
				pk := Tax_row.OID;
				cache_key := key_str;
				taxon_cached := pk;
			END LOOP;
		ELSE
			FOR Tax_row IN Tax_Name_c(Tax_NAME, TAX_OID_) LOOP
				IF (pk IS NOT NULL) THEN
				   raise_application_error(-20101,
			        'ambiguous reference to Tax <' || Tax_NAME || '|' || Tax_NCBI_TAXON_ID || '>');
				END IF;
				pk := Tax_row.OID;
				cache_key := key_str;
				taxon_cached := pk;
			END LOOP;
		END IF;
	END IF;
	-- insert/update if requested
	IF (pk IS NULL) AND 
	   ((do_DML = BSStd.DML_I) OR (do_DML = BSStd.DML_UI)) THEN
	    	-- insert the record and obtain the primary key
	    	pk := do_insert(
		        NAME => Tax_NAME,
			COMMON_NAME => Tax_COMMON_NAME,
			NCBI_TAXON_ID => Tax_NCBI_TAXON_ID,
			TAX_OID => TAX_OID_,
			NODE_TYPE => Tax_NODE_TYPE);
	ELSIF (do_DML = BSStd.DML_U) OR (do_DML = BSStd.DML_UI) THEN
	        -- update the record (note that not provided FKs will not
		-- be changed nor looked up)
		do_update(
			Tax_OID_	=> pk,
		        Tax_NAME => Tax_NAME,
			Tax_COMMON_NAME => Tax_COMMON_NAME,
			Tax_NCBI_TAXON_ID => Tax_NCBI_TAXON_ID,
			TaxP_OID => TAX_OID_,
			Tax_NODE_TYPE => Tax_NODE_TYPE);
	END IF;
	-- return the primary key
	RETURN pk;
END;

FUNCTION do_insert(
		NAME	IN SG_TAXON.NAME%TYPE,
		COMMON_NAME	IN SG_TAXON.COMMON_NAME%TYPE,
		NCBI_TAXON_ID	IN SG_TAXON.NCBI_TAXON_ID%TYPE,
		TAX_OID	IN SG_TAXON.TAX_OID%TYPE,
		NODE_TYPE	IN SG_TAXON.NODE_TYPE%TYPE)
RETURN SG_TAXON.OID%TYPE 
IS
	pk	SG_TAXON.OID%TYPE;
BEGIN
	-- pre-generate the primary key value
	SELECT SG_Sequence.nextval INTO pk FROM DUAL;
	-- insert the record
	INSERT INTO SG_TAXON (
		OID,
		NAME,
		COMMON_NAME,
		NCBI_TAXON_ID,
		TAX_OID,
		NODE_TYPE)
	VALUES (pk,
		NAME,
		COMMON_NAME,
		NCBI_TAXON_ID,
		TAX_OID,
		NODE_TYPE)
	;
	-- return the new pk value
	RETURN pk;
END;

PROCEDURE do_update(
		Tax_OID_	IN SG_TAXON.OID%TYPE,
		Tax_NAME	IN SG_TAXON.NAME%TYPE,
		Tax_COMMON_NAME	IN SG_TAXON.COMMON_NAME%TYPE,
		Tax_NCBI_TAXON_ID	IN SG_TAXON.NCBI_TAXON_ID%TYPE,
		TaxP_OID	IN SG_TAXON.TAX_OID%TYPE,
		Tax_NODE_TYPE	IN SG_TAXON.NODE_TYPE%TYPE)
IS
BEGIN
	-- update the record (and leave attributes passed as NULL untouched)
	UPDATE SG_TAXON t
	SET
		NAME = NVL(Tax_NAME, NAME),
		COMMON_NAME = NVL(Tax_COMMON_NAME, COMMON_NAME),
		NCBI_TAXON_ID = NVL(Tax_NCBI_TAXON_ID, NCBI_TAXON_ID),
		TAX_OID = NVL(TaxP_OID, TAX_OID),
		NODE_TYPE = NVL(Tax_NODE_TYPE, NODE_TYPE)
	WHERE OID = Tax_OID_
	;
END;

END Tax;
/

