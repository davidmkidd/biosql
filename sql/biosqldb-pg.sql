--- conventions: 
--- <table_name>_id is primary internal id (usually autogenerated) 
--- author Ewan Birney  
--- comments to bioperl - bioperl-l@bioperl.org 
--- database have bioentries. That is about it. 
--- we do not store different versions of a database as different dbids 
--- (there is no concept of versions of database). There is a concept of 
--- versions of entries. Versions of databases deserve their own table and 
--- join to bioentry table for tracking with versions of entries  
CREATE SEQUENCE biodatabase_pkey_seq;
CREATE TABLE biodatabase ( 
	 biodatabase_id integer primary key default (nextval ( 'biodatabase_pkey_seq' )) , 
	 name varchar ( 40 ) NOT NULL ); 

CREATE INDEX biodatabaseidx1 on biodatabase ( name ); 
--- we could insist that taxa are NCBI taxa id, but on reflection I made this 
--- an optional extra line, as many flat file formats do not have the NCBI id 
--- full lineage is : delimited string starting with species. 
--- no organelle/sub species 
CREATE SEQUENCE taxa_pkey_seq;
CREATE TABLE taxa ( 
	 taxa_id integer primary key default (nextval ( 'taxa_pkey_seq' )) , 
	 full_lineage text NOT NULL , 
	 common_name varchar ( 255 ) NOT NULL , 
	 ncbi_taxa_id int ); 

CREATE INDEX taxancbi ON taxa ( ncbi_taxa_id ); 
CREATE INDEX taxaname ON taxa ( common_name ); 
--- any controlled vocab term, everything from full ontology 
--- terms eg GO IDs to the various keys allowed as qualifiers 
--- 
--- this replaces the table "seqfeature_qualifier" 
CREATE SEQUENCE ontology_term_pkey_seq;
CREATE TABLE ontology_term ( 
	 ontology_term_id integer primary key default (nextval ( 'ontology_term_pkey_seq' )) , 
	 term_name char ( 255 ) , 
	 term_definition text ); 

CREATE INDEX otn ON ontology_term ( term_name ); 
--- we can be a bioentry without a biosequence, but not visa-versa 
--- most things are going to be keyed off bioentry_id 
--- accession is the stable id, display_id is a potentially volatile, 
--- human readable name. 
CREATE SEQUENCE bioentry_pkey_seq;
CREATE TABLE bioentry ( 
	 bioentry_id integer primary key default (nextval ( 'bioentry_pkey_seq' )) , 
	 biodatabase_id int NOT NULL , 
	 display_id varchar ( 40 ) NOT NULL , 
	 accession varchar ( 40 ) NOT NULL , 
	 entry_version int , 
	 division varchar ( 3 ) NOT NULL , 
	 UNIQUE ( biodatabase_id , accession , entry_version , division ) , 
	 FOREIGN KEY ( biodatabase_id ) REFERENCES biodatabase ( biodatabase_id ) ); 

CREATE INDEX bioentrydbid ON bioentry ( biodatabase_id ); 
CREATE INDEX bioentrydid ON bioentry ( display_id ); 
CREATE INDEX bioentryacc ON bioentry ( accession ); 
--- not all entries have a taxa, but many do. 
--- one bioentry only has one taxa! (weirdo chimerias are not handled. tough) 
CREATE TABLE bioentry_taxa ( 
	 bioentry_id int NOT NULL , 
	 taxa_id int NOT NULL , 
	 FOREIGN KEY ( bioentry_id ) REFERENCES bioentry ( bioentry_id ) , 
	 PRIMARY KEY ( bioentry_id ) ); 

CREATE INDEX bioentrytax ON bioentry_taxa ( taxa_id ); 
--- some bioentries will have a sequence 
--- biosequence because sequence is sometimes  
--- a reserved word 
--- removed not null for seq_version; cjm 
CREATE SEQUENCE biosequence_pkey_seq;
CREATE TABLE biosequence ( 
	 biosequence_id integer primary key default (nextval ( 'biosequence_pkey_seq' )) , 
	 bioentry_id int NOT NULL , 
	 seq_version int , 
	 seq_length int , 
	 biosequence_str text , 
	 molecule varchar ( 10 ) , 
	 FOREIGN KEY ( bioentry_id ) REFERENCES bioentry ( bioentry_id ) , 
	 UNIQUE ( bioentry_id ) ); 

CREATE INDEX biosequenceeid ON biosequence ( bioentry_id ); 
--- new table 
CREATE SEQUENCE dbxref_pkey_seq;
CREATE TABLE dbxref ( 
	 dbxref_id integer primary key default (nextval ( 'dbxref_pkey_seq' )) , 
	 dbname varchar ( 40 ) NOT NULL , 
	 accession varchar ( 40 ) NOT NULL , 
	 UNIQUE ( dbname , accession ) ); 

CREATE INDEX dbxrefdbn ON dbxref ( dbname ); 
CREATE INDEX dbxrefacc ON dbxref ( accession ); 
--- new table 
--- for roundtripping embl/genbank, we need to have the "optional ID" 
--- for the dbxref. 
--- 
--- another use of this table could be for storing 
--- descriptive text for a dbxref. for example, we may want to 
--- know stuff about the interpro accessions we store (without 
--- importing all of interpro), so we can attach the text 
--- description as a synonym 
--- 
CREATE SEQUENCE dbxref_qualifier_value_pkey_seq;
CREATE TABLE dbxref_qualifier_value ( 
	 dbxref_qualifier_value_id integer primary key default (nextval ( 'dbxref_qualifier_value_pkey_seq' )) , 
	 dbxref_id int NOT NULL , 
	 FOREIGN KEY ( dbxref_id ) REFERENCES dbxref ( dbxref_id ) , 
	 ontology_term_id int NOT NULL , 
	 FOREIGN KEY ( ontology_term_id ) REFERENCES ontology_term ( ontology_term_id ) , 
	 qualifier_value text ); 

CREATE INDEX dqv1 ON dbxref_qualifier_value ( dbxref_id ); 
CREATE INDEX dqv2 ON dbxref_qualifier_value ( ontology_term_id ); 
--- Direct links. It is tempting to do this 
--- from bioentry_id to bioentry_id. But that wont work 
--- during updates of one database - we will have to edit 
--- this table each time. Better to do the join through accession 
--- and db each time. Should be almost as cheap 
--- note: changed to use new dbxref table 
CREATE SEQUENCE bioentry_direct_links_pkey_seq;
CREATE TABLE bioentry_direct_links ( 
	 bio_dblink_id integer primary key default (nextval ( 'bioentry_direct_links_pkey_seq' )) , 
	 source_bioentry_id int NOT NULL , 
	 dbxref_id int NOT NULL , 
	 FOREIGN KEY ( source_bioentry_id ) REFERENCES bioentry ( bioentry_id ) , 
	 FOREIGN KEY ( dbxref_id ) REFERENCES dbxref ( dbxref_id ) ); 

CREATE INDEX bdl1 ON bioentry_direct_links ( source_bioentry_id ); 
CREATE INDEX bdl2 ON bioentry_direct_links ( dbxref_id ); 
---We can have multiple references per bioentry, but one reference 
---can also be used for the same bioentry. 
CREATE SEQUENCE reference_pkey_seq;
CREATE TABLE reference ( 
	 reference_id integer primary key default (nextval ( 'reference_pkey_seq' )) , 
	 reference_location text NOT NULL , 
	 reference_title text , 
	 reference_authors text NOT NULL , 
	 reference_medline int ); 

CREATE INDEX medlineidx ON reference ( reference_medline ); 
CREATE TABLE bioentry_reference ( 
	 bioentry_id int NOT NULL , 
	 reference_id int NOT NULL , 
	 reference_start int , 
	 reference_end int , 
	 reference_rank int NOT NULL , 
	 PRIMARY KEY ( bioentry_id , reference_id , reference_rank ) , 
	 FOREIGN KEY ( bioentry_id ) REFERENCES bioentry ( bioentry_id ) , 
	 FOREIGN KEY ( reference_id ) REFERENCES reference ( reference_id ) ); 

CREATE INDEX reference_rank_idx ON bioentry_reference ( reference_rank ); 
CREATE INDEX reference_rank_idx2 ON bioentry_reference ( bioentry_id ); 
CREATE INDEX reference_rank_idx3 ON bioentry_reference ( reference_id ); 
CREATE INDEX reference_rank_idx4 ON bioentry_reference ( reference_rank ); 
CREATE INDEX reference_rank_idx5 ON bioentry_reference ( bioentry_id , reference_rank ); 
--- We can have multiple comments per seqentry, and 
--- comments can have embedded '\n' characters 
CREATE SEQUENCE comment_pkey_seq;
CREATE TABLE comment ( 
	 comment_id integer primary key default (nextval ( 'comment_pkey_seq' )) , 
	 bioentry_id int NOT NULL , 
	 comment_text text NOT NULL , 
	 comment_rank int NOT NULL , 
	 FOREIGN KEY ( bioentry_id ) REFERENCES bioentry ( bioentry_id ) ); 

CREATE INDEX cmtidx1 ON comment ( bioentry_id ); 
--- separate description table separate to save on space when we 
--- do not store descriptions 
--- this table replaces the old 
---  bioentry_description and bioentry_keywords tables 
CREATE TABLE bioentry_qualifier_value ( 
	 bioentry_id int NOT NULL , 
	 FOREIGN KEY ( bioentry_id ) REFERENCES bioentry ( bioentry_id ) , 
	 ontology_term_id int NOT NULL , 
	 FOREIGN KEY ( ontology_term_id ) REFERENCES ontology_term ( ontology_term_id ) , 
	 qualifier_value text ); 

CREATE INDEX bqv1 ON bioentry_qualifier_value ( bioentry_id ); 
CREATE INDEX bqv2 ON bioentry_qualifier_value ( ontology_term_id ); 
CREATE INDEX bqv3 ON bioentry_qualifier_value ( bioentry_id , ontology_term_id ); 
--- feature table. We cleanly handle 
---   - simple locations 
---   - split locations 
---   - split locations on remote sequences 
--- The fuzzies are not handled yet 
CREATE SEQUENCE seqfeature_source_pkey_seq;
CREATE TABLE seqfeature_source ( 
	 seqfeature_source_id integer primary key default (nextval ( 'seqfeature_source_pkey_seq' )) , 
	 source_name varchar ( 255 ) NOT NULL ); 

CREATE SEQUENCE seqfeature_pkey_seq;
CREATE TABLE seqfeature ( 
	 seqfeature_id integer primary key default (nextval ( 'seqfeature_pkey_seq' )) , 
	 bioentry_id int NOT NULL , 
	 seqfeature_key_id int , 
	 seqfeature_source_id int , 
	 seqfeature_rank int , 
	 FOREIGN KEY ( seqfeature_key_id ) REFERENCES ontology_term ( ontology_term_id ) , 
	 FOREIGN KEY ( seqfeature_source_id ) REFERENCES seqfeature_source ( seqfeature_source_id ) , 
	 FOREIGN KEY ( bioentry_id ) REFERENCES bioentry ( bioentry_id ) ); 

CREATE INDEX sf1 ON seqfeature ( seqfeature_key_id ); 
CREATE INDEX sf2 ON seqfeature ( seqfeature_source_id ); 
CREATE INDEX sf3 ON seqfeature ( bioentry_id ); 
CREATE TABLE seqfeature_qualifier_value ( 
	 seqfeature_id int NOT NULL , 
	 ontology_term_id int NOT NULL , 
	 qualifier_rank int NOT NULL , 
	 qualifier_value text NOT NULL , 
	 FOREIGN KEY ( ontology_term_id ) REFERENCES ontology_term ( ontology_term_id ) , 
	 PRIMARY KEY ( seqfeature_id , ontology_term_id , qualifier_rank ) ); 

CREATE INDEX sqv1 ON seqfeature_qualifier_value ( ontology_term_id ); 
